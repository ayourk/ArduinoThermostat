<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>7-Segment Font Generator for Adafruit GFX</title>
    <style>
        body {
            font-family: monospace;
            background: #1a1a2e;
            color: #fff;
            padding: 20px;
        }
        .controls {
            background: #2a2a2a;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
        }
        .controls label {
            display: block;
            margin: 10px 0 5px;
        }
        .controls input {
            padding: 5px;
            font-size: 14px;
        }
        button {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 10px 20px;
            font-size: 16px;
            cursor: pointer;
            margin: 10px 5px 10px 0;
            border-radius: 4px;
        }
        button:hover { background: #45a049; }
        .preview {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin: 20px 0;
        }
        .preview canvas {
            background: #000;
            border: 1px solid #444;
        }
        .preview .digit-label {
            text-align: center;
            color: #888;
            font-size: 12px;
        }
        #output {
            background: #000;
            color: #0f0;
            padding: 15px;
            border-radius: 8px;
            white-space: pre;
            overflow-x: auto;
            font-size: 11px;
            max-height: 400px;
            overflow-y: auto;
        }
        h2 { color: #FFFF00; margin-top: 30px; }
    </style>
</head>
<body>
    <h1>7-Segment Font Generator for Adafruit GFX</h1>
    
    <div class="controls">
        <label>Digit Width (pixels): <input type="number" id="digitWidth" value="36" min="10" max="100"></label>
        <label>Font Name: <input type="text" id="fontName" value="LCD7segment48pt7b"></label>
        <button onclick="generateFont()">Generate Font Header</button>
        <button onclick="copyToClipboard()">Copy to Clipboard</button>
    </div>
    
    <h2>Preview</h2>
    <div class="preview" id="preview"></div>
    
    <h2>Generated Header</h2>
    <pre id="output">Click "Generate Font Header" to create the .h file content</pre>

    <script>
        // 7-segment definitions [A, B, C, D, E, F, G]
        const segmentMap = {
            '0': [1,1,1,1,1,1,0],
            '1': [0,1,1,0,0,0,0],
            '2': [1,1,0,1,1,0,1],
            '3': [1,1,1,1,0,0,1],
            '4': [0,1,1,0,0,1,1],
            '5': [1,0,1,1,0,1,1],
            '6': [1,0,1,1,1,1,1],
            '7': [1,1,1,0,0,0,0],
            '8': [1,1,1,1,1,1,1],
            '9': [1,1,1,1,0,1,1],
        };

        /**
         * Draw a 7-segment digit to a canvas context
         * Returns the calculated height
         */
        function draw7Seg(ctx, x, y, digit, width) {
            const segs = segmentMap[digit] || segmentMap['8'];
            
            const W = width;
            const t = Math.max(3, Math.round(W * 0.15));
            const halfT = t / 2;
            const gap = Math.max(1, Math.round(t * 0.12));
            const H = 2 * W - t;
            const midY = y + W - halfT;
            
            ctx.fillStyle = '#FFFFFF';
            
            function drawHSeg(leftTip, rightTip, cy) {
                ctx.beginPath();
                ctx.moveTo(leftTip, cy);
                ctx.lineTo(leftTip + halfT, cy - halfT);
                ctx.lineTo(rightTip - halfT, cy - halfT);
                ctx.lineTo(rightTip, cy);
                ctx.lineTo(rightTip - halfT, cy + halfT);
                ctx.lineTo(leftTip + halfT, cy + halfT);
                ctx.closePath();
                ctx.fill();
            }
            
            function drawVSeg(cx, topTip, bottomTip) {
                ctx.beginPath();
                ctx.moveTo(cx, topTip);
                ctx.lineTo(cx + halfT, topTip + halfT);
                ctx.lineTo(cx + halfT, bottomTip - halfT);
                ctx.lineTo(cx, bottomTip);
                ctx.lineTo(cx - halfT, bottomTip - halfT);
                ctx.lineTo(cx - halfT, topTip + halfT);
                ctx.closePath();
                ctx.fill();
            }
            
            const aY = y + halfT;
            const gY = midY;
            const dY = y + H - halfT;
            const hLeft = x + halfT + gap;
            const hRight = x + W - halfT - gap;
            const vLeftX = x + halfT;
            const vRightX = x + W - halfT;
            const topSegTop = y + halfT + gap;
            const topSegBot = midY - gap;
            const botSegTop = midY + gap;
            const botSegBot = y + H - halfT - gap;
            
            if (segs[0]) drawHSeg(hLeft, hRight, aY);
            if (segs[1]) drawVSeg(vRightX, topSegTop, topSegBot);
            if (segs[2]) drawVSeg(vRightX, botSegTop, botSegBot);
            if (segs[3]) drawHSeg(hLeft, hRight, dY);
            if (segs[4]) drawVSeg(vLeftX, botSegTop, botSegBot);
            if (segs[5]) drawVSeg(vLeftX, topSegTop, topSegBot);
            if (segs[6]) drawHSeg(hLeft, hRight, gY);
            
            return H;
        }

        /**
         * Get bitmap data from a canvas as array of bytes (1 bit per pixel, MSB first)
         */
        function getBitmapBytes(canvas) {
            const ctx = canvas.getContext('2d');
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const pixels = imageData.data;
            const bytes = [];
            
            let currentByte = 0;
            let bitIndex = 0;
            
            for (let y = 0; y < canvas.height; y++) {
                for (let x = 0; x < canvas.width; x++) {
                    const idx = (y * canvas.width + x) * 4;
                    // Check if pixel is "on" (any color channel > 128)
                    const isOn = pixels[idx] > 128 || pixels[idx + 1] > 128 || pixels[idx + 2] > 128;
                    
                    if (isOn) {
                        currentByte |= (1 << (7 - bitIndex));
                    }
                    
                    bitIndex++;
                    if (bitIndex === 8) {
                        bytes.push(currentByte);
                        currentByte = 0;
                        bitIndex = 0;
                    }
                }
            }
            
            // Push final partial byte if any
            if (bitIndex > 0) {
                bytes.push(currentByte);
            }
            
            return bytes;
        }

        /**
         * Generate the font header file
         */
        function generateFont() {
            const digitWidth = parseInt(document.getElementById('digitWidth').value);
            const fontName = document.getElementById('fontName').value;
            
            const t = Math.max(3, Math.round(digitWidth * 0.15));
            const digitHeight = 2 * digitWidth - t;
            
            // Clear preview
            const preview = document.getElementById('preview');
            preview.innerHTML = '';
            
            const allBitmapBytes = [];
            const glyphs = [];
            const digits = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9'];
            
            // Generate each digit
            for (const digit of digits) {
                // Create canvas for this digit
                const canvas = document.createElement('canvas');
                canvas.width = digitWidth;
                canvas.height = digitHeight;
                const ctx = canvas.getContext('2d');
                
                // Clear canvas
                ctx.fillStyle = '#000000';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // Draw digit
                draw7Seg(ctx, 0, 0, digit, digitWidth);
                
                // Add to preview
                const wrapper = document.createElement('div');
                wrapper.innerHTML = `<div class="digit-label">${digit}</div>`;
                wrapper.insertBefore(canvas, wrapper.firstChild);
                preview.appendChild(wrapper);
                
                // Get bitmap bytes
                const bitmapOffset = allBitmapBytes.length;
                const bytes = getBitmapBytes(canvas);
                allBitmapBytes.push(...bytes);
                
                // Glyph entry: {offset, width, height, xAdvance, xOffset, yOffset}
                glyphs.push({
                    offset: bitmapOffset,
                    width: digitWidth,
                    height: digitHeight,
                    xAdvance: digitWidth + 4, // Add small spacing between digits
                    xOffset: 0,
                    yOffset: -digitHeight + 1
                });
            }
            
            // Generate header file content
            let output = '';
            
            // Bitmap array
            output += `const uint8_t ${fontName}Bitmaps[] PROGMEM = {\n`;
            for (let i = 0; i < allBitmapBytes.length; i++) {
                if (i % 12 === 0) output += '  ';
                output += '0x' + allBitmapBytes[i].toString(16).padStart(2, '0').toUpperCase();
                if (i < allBitmapBytes.length - 1) output += ', ';
                if ((i + 1) % 12 === 0) output += '\n';
            }
            if (allBitmapBytes.length % 12 !== 0) output += '\n';
            output += '};\n\n';
            
            // Glyph table - includes entries from 0x30 '0' to 0xB0 '°'
            output += `const GFXglyph ${fontName}Glyphs[] PROGMEM = {\n`;
            
            // Digits 0-9 (0x30-0x39)
            for (let i = 0; i < 10; i++) {
                const g = glyphs[i];
                output += `  { ${g.offset.toString().padStart(5)}, ${g.width.toString().padStart(3)}, ${g.height.toString().padStart(3)}, ${g.xAdvance.toString().padStart(3)}, ${g.xOffset.toString().padStart(4)}, ${g.yOffset.toString().padStart(5)} },   // 0x3${i} '${i}'\n`;
            }
            
            // Empty entries for : ; < = > ? @ A-Z [ \\ ] ^ _ \` a-z { | } ~ and extended chars up to °
            const emptyChars = [];
            for (let c = 0x3A; c <= 0xAF; c++) {
                let charName = String.fromCharCode(c);
                if (c < 0x20 || c === 0x7F || c === 0xAD) charName = 'non-printable';
                emptyChars.push({ code: c, name: charName });
            }
            
            for (const ec of emptyChars) {
                output += `  {     0,   0,   0,   0,    0,    0 },   // 0x${ec.code.toString(16).toUpperCase()} '${ec.name}'\n`;
            }
            
            // Degree symbol at 0xB0 - create a small circle
            const degCanvas = document.createElement('canvas');
            const degSize = Math.round(digitWidth * 0.25);
            degCanvas.width = degSize;
            degCanvas.height = degSize;
            const degCtx = degCanvas.getContext('2d');
            degCtx.fillStyle = '#000000';
            degCtx.fillRect(0, 0, degSize, degSize);
            degCtx.strokeStyle = '#FFFFFF';
            degCtx.lineWidth = Math.max(1, Math.round(degSize * 0.2));
            degCtx.beginPath();
            degCtx.arc(degSize / 2, degSize / 2, degSize / 2 - degCtx.lineWidth, 0, Math.PI * 2);
            degCtx.stroke();
            
            const degOffset = allBitmapBytes.length;
            const degBytes = getBitmapBytes(degCanvas);
            allBitmapBytes.push(...degBytes);
            
            output += `  { ${degOffset.toString().padStart(5)}, ${degSize.toString().padStart(3)}, ${degSize.toString().padStart(3)}, ${(degSize + 2).toString().padStart(3)}, ${('1').padStart(4)}, ${(-digitHeight + 1).toString().padStart(5)} }    // 0xB0 '°'\n`;
            
            output += '};\n\n';
            
            // Font structure
            output += `const GFXfont ${fontName} PROGMEM = {\n`;
            output += `  (uint8_t  *)${fontName}Bitmaps,\n`;
            output += `  (GFXglyph *)${fontName}Glyphs,\n`;
            output += `  0x30, 0xB0, ${digitHeight + 2}\n`;
            output += '};\n\n';
            output += `// Approx. ${allBitmapBytes.length + glyphs.length * 6 + 100} bytes\n`;
            output += `// Digit dimensions: ${digitWidth}w x ${digitHeight}h, thickness: ${t}px\n`;
            
            document.getElementById('output').textContent = output;
            
            // Update bitmap array with degree symbol
            // Regenerate output with complete bitmap
            let finalOutput = '';
            finalOutput += `const uint8_t ${fontName}Bitmaps[] PROGMEM = {\n`;
            for (let i = 0; i < allBitmapBytes.length; i++) {
                if (i % 12 === 0) finalOutput += '  ';
                finalOutput += '0x' + allBitmapBytes[i].toString(16).padStart(2, '0').toUpperCase();
                if (i < allBitmapBytes.length - 1) finalOutput += ', ';
                if ((i + 1) % 12 === 0) finalOutput += '\n';
            }
            if (allBitmapBytes.length % 12 !== 0) finalOutput += '\n';
            finalOutput += '};\n\n';
            finalOutput += output.substring(output.indexOf('const GFXglyph'));
            
            document.getElementById('output').textContent = finalOutput;
        }

        function copyToClipboard() {
            const output = document.getElementById('output').textContent;
            navigator.clipboard.writeText(output).then(() => {
                alert('Copied to clipboard!');
            });
        }

        // Generate on load
        window.onload = generateFont;
    </script>
</body>
</html>
